/**
  Generated main.c file from MPLAB Code Configurator

  @Company
    Microchip Technology Inc.

  @File Name
    main.c

  @Summary
    This is the generated main.c using PIC24 / dsPIC33 / PIC32MM MCUs.

  @Description
    This source file provides main entry point for system initialization and application code development.
    Generation Information :
        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.166.0
        Device            :  PIC24FJ128GC010
    The generated drivers are tested against the following:
        Compiler          :  XC16 v1.41
        MPLAB 	          :  MPLAB X v5.30
*/

/*
    (c) 2019 Microchip Technology Inc. and its subsidiaries. You may use this
    software and any derivatives exclusively with Microchip products.

    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.

    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.

    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
    TERMS.
*/

/**
  Section: Included Files
*/
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <ctype.h>
#include <stdint.h>
#include <stdbool.h>

#include <p24FJ128GC010.h>

#include "mcc_generated_files/system.h"
#include "mcc_generated_files/i2c2.h"
#include "xc.h"

#define FOSC    (8000000ULL)
#define FCY     (FOSC/2)
#define I2C2_SCL_TRIS	TRISFbits.TRISF5
#define I2C2_SDA_TRIS	TRISFbits.TRISF4
#define I2C2_SCL_LAT	LATFbits.LATF5
#define I2C2_SDA_LAT	LATFbits.LATF4

#define kI2C_100KHZ     (0x00)
#define kI2C_400KHZ     (0x02)

#define SSD1308_Address                 0x3C/2
#define SSD1308_Command_Mode		0x80
#define SSD1308_Data_Mode               0x40
#define SSD1308_Display_Off_Cmd         0xAE
#define SSD1308_Display_On_Cmd          0xAF
#define SSD1308_Normal_Display_Cmd      0xA6
#define SSD1308_Inverse_Display_Cmd	0xA7
#define SSD1308_Activate_Scroll_Cmd	0x2F
#define SSD1308_Dectivate_Scroll_Cmd	0x2E
#define SSD1308_Set_Brightness_Cmd      0x81

I2C2_MESSAGE_STATUS status = I2C2_MESSAGE_PENDING;


const uint8_t OledFont[][8] =
{
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
  {0x00,0x00,0x5F,0x00,0x00,0x00,0x00,0x00},
  {0x00,0x00,0x07,0x00,0x07,0x00,0x00,0x00},
  {0x00,0x14,0x7F,0x14,0x7F,0x14,0x00,0x00},
  {0x00,0x24,0x2A,0x7F,0x2A,0x12,0x00,0x00},
  {0x00,0x23,0x13,0x08,0x64,0x62,0x00,0x00},
  {0x00,0x36,0x49,0x55,0x22,0x50,0x00,0x00},
  {0x00,0x00,0x05,0x03,0x00,0x00,0x00,0x00},
  {0x00,0x1C,0x22,0x41,0x00,0x00,0x00,0x00},
  {0x00,0x41,0x22,0x1C,0x00,0x00,0x00,0x00},
  {0x00,0x08,0x2A,0x1C,0x2A,0x08,0x00,0x00},
  {0x00,0x08,0x08,0x3E,0x08,0x08,0x00,0x00},
  {0x00,0xA0,0x60,0x00,0x00,0x00,0x00,0x00},
  {0x00,0x08,0x08,0x08,0x08,0x08,0x00,0x00},
  {0x00,0x60,0x60,0x00,0x00,0x00,0x00,0x00},
  {0x00,0x20,0x10,0x08,0x04,0x02,0x00,0x00},
  {0x00,0x3E,0x51,0x49,0x45,0x3E,0x00,0x00},
  {0x00,0x00,0x42,0x7F,0x40,0x00,0x00,0x00},
  {0x00,0x62,0x51,0x49,0x49,0x46,0x00,0x00},
  {0x00,0x22,0x41,0x49,0x49,0x36,0x00,0x00},
  {0x00,0x18,0x14,0x12,0x7F,0x10,0x00,0x00},
  {0x00,0x27,0x45,0x45,0x45,0x39,0x00,0x00},
  {0x00,0x3C,0x4A,0x49,0x49,0x30,0x00,0x00},
  {0x00,0x01,0x71,0x09,0x05,0x03,0x00,0x00},
  {0x00,0x36,0x49,0x49,0x49,0x36,0x00,0x00},
  {0x00,0x06,0x49,0x49,0x29,0x1E,0x00,0x00},
  {0x00,0x00,0x36,0x36,0x00,0x00,0x00,0x00},
  {0x00,0x00,0xAC,0x6C,0x00,0x00,0x00,0x00},
  {0x00,0x08,0x14,0x22,0x41,0x00,0x00,0x00},
  {0x00,0x14,0x14,0x14,0x14,0x14,0x00,0x00},
  {0x00,0x41,0x22,0x14,0x08,0x00,0x00,0x00},
  {0x00,0x02,0x01,0x51,0x09,0x06,0x00,0x00},
  {0x00,0x32,0x49,0x79,0x41,0x3E,0x00,0x00},
  {0x00,0x7E,0x09,0x09,0x09,0x7E,0x00,0x00},
  {0x00,0x7F,0x49,0x49,0x49,0x36,0x00,0x00},
  {0x00,0x3E,0x41,0x41,0x41,0x22,0x00,0x00},
  {0x00,0x7F,0x41,0x41,0x22,0x1C,0x00,0x00},
  {0x00,0x7F,0x49,0x49,0x49,0x41,0x00,0x00},
  {0x00,0x7F,0x09,0x09,0x09,0x01,0x00,0x00},
  {0x00,0x3E,0x41,0x41,0x51,0x72,0x00,0x00},
  {0x00,0x7F,0x08,0x08,0x08,0x7F,0x00,0x00},
  {0x00,0x41,0x7F,0x41,0x00,0x00,0x00,0x00},
  {0x00,0x20,0x40,0x41,0x3F,0x01,0x00,0x00},
  {0x00,0x7F,0x08,0x14,0x22,0x41,0x00,0x00},
  {0x00,0x7F,0x40,0x40,0x40,0x40,0x00,0x00},
  {0x00,0x7F,0x02,0x0C,0x02,0x7F,0x00,0x00},
  {0x00,0x7F,0x04,0x08,0x10,0x7F,0x00,0x00},
  {0x00,0x3E,0x41,0x41,0x41,0x3E,0x00,0x00},
  {0x00,0x7F,0x09,0x09,0x09,0x06,0x00,0x00},
  {0x00,0x3E,0x41,0x51,0x21,0x5E,0x00,0x00},
  {0x00,0x7F,0x09,0x19,0x29,0x46,0x00,0x00},
  {0x00,0x26,0x49,0x49,0x49,0x32,0x00,0x00},
  {0x00,0x01,0x01,0x7F,0x01,0x01,0x00,0x00},
  {0x00,0x3F,0x40,0x40,0x40,0x3F,0x00,0x00},
  {0x00,0x1F,0x20,0x40,0x20,0x1F,0x00,0x00},
  {0x00,0x3F,0x40,0x38,0x40,0x3F,0x00,0x00},
  {0x00,0x63,0x14,0x08,0x14,0x63,0x00,0x00},
  {0x00,0x03,0x04,0x78,0x04,0x03,0x00,0x00},
  {0x00,0x61,0x51,0x49,0x45,0x43,0x00,0x00},
  {0x00,0x7F,0x41,0x41,0x00,0x00,0x00,0x00},
  {0x00,0x02,0x04,0x08,0x10,0x20,0x00,0x00},
  {0x00,0x41,0x41,0x7F,0x00,0x00,0x00,0x00},
  {0x00,0x04,0x02,0x01,0x02,0x04,0x00,0x00},
  {0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00},
  {0x00,0x01,0x02,0x04,0x00,0x00,0x00,0x00},
  {0x00,0x20,0x54,0x54,0x54,0x78,0x00,0x00},
  {0x00,0x7F,0x48,0x44,0x44,0x38,0x00,0x00},
  {0x00,0x38,0x44,0x44,0x28,0x00,0x00,0x00},
  {0x00,0x38,0x44,0x44,0x48,0x7F,0x00,0x00},
  {0x00,0x38,0x54,0x54,0x54,0x18,0x00,0x00},
  {0x00,0x08,0x7E,0x09,0x02,0x00,0x00,0x00},
  {0x00,0x18,0xA4,0xA4,0xA4,0x7C,0x00,0x00},
  {0x00,0x7F,0x08,0x04,0x04,0x78,0x00,0x00},
  {0x00,0x00,0x7D,0x00,0x00,0x00,0x00,0x00},
  {0x00,0x80,0x84,0x7D,0x00,0x00,0x00,0x00},
  {0x00,0x7F,0x10,0x28,0x44,0x00,0x00,0x00},
  {0x00,0x41,0x7F,0x40,0x00,0x00,0x00,0x00},
  {0x00,0x7C,0x04,0x18,0x04,0x78,0x00,0x00},
  {0x00,0x7C,0x08,0x04,0x7C,0x00,0x00,0x00},
  {0x00,0x38,0x44,0x44,0x38,0x00,0x00,0x00},
  {0x00,0xFC,0x24,0x24,0x18,0x00,0x00,0x00},
  {0x00,0x18,0x24,0x24,0xFC,0x00,0x00,0x00},
  {0x00,0x00,0x7C,0x08,0x04,0x00,0x00,0x00},
  {0x00,0x48,0x54,0x54,0x24,0x00,0x00,0x00},
  {0x00,0x04,0x7F,0x44,0x00,0x00,0x00,0x00},
  {0x00,0x3C,0x40,0x40,0x7C,0x00,0x00,0x00},
  {0x00,0x1C,0x20,0x40,0x20,0x1C,0x00,0x00},
  {0x00,0x3C,0x40,0x30,0x40,0x3C,0x00,0x00},
  {0x00,0x44,0x28,0x10,0x28,0x44,0x00,0x00},
  {0x00,0x1C,0xA0,0xA0,0x7C,0x00,0x00,0x00},
  {0x00,0x44,0x64,0x54,0x4C,0x44,0x00,0x00},
  {0x00,0x08,0x36,0x41,0x00,0x00,0x00,0x00},
  {0x00,0x00,0x7F,0x00,0x00,0x00,0x00,0x00},
  {0x00,0x41,0x36,0x08,0x00,0x00,0x00,0x00},
  {0x00,0x02,0x01,0x01,0x02,0x01,0x00,0x00},
  {0x00,0x02,0x05,0x05,0x02,0x00,0x00,0x00}
};

/*
                         Main application
 */

void __delay_ms(uint16_t count){
    uint64_t n = count * 10;
    uint64_t i;
    for(i = 0; i < n; i++){
        Nop();
    }
}

void i2c2Disable()
{
    I2C2CONbits.I2CEN = 0;
}

void i2c2Reset()
{
    // first make sure I2C module is disabled
    i2c2Disable();

    // hold SCL low for 100 ms to reset I2C bus
    I2C2_SCL_TRIS = 0;
    I2C2_SCL_LAT = 0;
    uint8_t i;
    for ( i = 0; i < 10; i++ )
        __delay_ms( 10 );
    // tri-date SCL and SDA
    I2C2_SCL_TRIS = 1;
    I2C2_SDA_TRIS = 1;
    __delay_ms( 10 );
}

void i2c2Enable( uint8_t flags )
{
    // Calculate BGP from FCY
    // brg = ( FCY/FSCL - FCY/10000000) - 1
    uint32_t fscl = ( flags & kI2C_400KHZ ) ? 400000UL : 100000UL;
    uint16_t brg = ( ( FCY / fscl ) - ( FCY / 1000000 ) ) - 1;
    //I2C2BRG = brg;
    I2C2BRG = 0x27;

    // enable I2C module
    I2C2CONbits.I2CEN = 1;
}

int16_t i2c2XferInt(
	uint8_t address,
	uint8_t* wdata, int wsize,
	uint8_t* rdata, int rsize )
{
    int16_t count = 0;
    uint32_t i;
    bool hasWrite = ( wdata != NULL ) && ( wsize != 0 );
    bool hasRead = ( rdata != NULL ) && ( rsize != 0 );
    if ( ! ( hasWrite || hasRead ) ) return -1;

    // clear bus collision
    I2C2STATbits.BCL = 0;

    // generate start condition
    I2C2CONbits.SEN = 1;
    while ( 1 ) {
        if ( I2C2STATbits.BCL ) return -2;
        if ( ! I2C2CONbits.SEN ) break;
    }

    // Send 7-bit slave address and Read/Write flag
    I2C2TRN = ( address << 1 ) | ( hasWrite ? 0x00 : 0x01 );
    while ( 1 ) {
        if ( I2C2STATbits.BCL ) return -3;
        if ( ! I2C2STATbits.TRSTAT ) break;
    }

    if ( I2C2STATbits.ACKSTAT ) return -4;

    // Write data
    for ( i = 0; i < wsize; i++ ) {
        I2C2TRN = wdata[ i ];
        while ( 1 ) {
            if ( I2C2STATbits.BCL ) return -5;
            if ( ! I2C2STATbits.TRSTAT ) break;
        }
        if ( I2C2STATbits.ACKSTAT ) return -6;
    }

    if ( hasRead ) {
        // if we've been writing, send a Repeated Start
        if ( hasWrite ) {
            // generate start condition
            I2C2CONbits.RSEN = 1;
            while ( 1 ) {
                if ( I2C2STATbits.BCL ) return -7;
                if ( ! I2C2CONbits.RSEN ) break;
            }

            // Send 7-bit slave address with Read flag
            I2C2TRN = ( address << 1 ) | 0x01;
            while ( 1 ) {
                if ( I2C2STATbits.BCL ) return -8;
                if ( ! I2C2STATbits.TRSTAT ) break;
            }
            if ( I2C2STATbits.ACKSTAT ) return -9;
        }

        // Read data
        for ( i = 0; i < rsize; i++ ) {
            // check idle
            if ( I2C2CON & 0x1F ) return -10;

            // enable reception
            I2C2CONbits.RCEN = 1;
            while ( 1 ) {
                if ( I2C2STATbits.BCL ) return -11;
                if ( ! I2C2CONbits.RCEN ) break;
            }

            // read data byte from buffer
            rdata[ i ] = I2C2RCV;
            count++;

            // send acknowledge (or not acknowledge for final byte)
            I2C2CONbits.ACKDT = i == ( rsize - 1 ) ? 1 : 0;
            I2C2CONbits.ACKEN = 1;
            while ( 1 ) {
                if ( I2C2STATbits.BCL ) return -12;
                if ( ! I2C2CONbits.ACKEN ) break;
            }
        }
    }

    // Generate stop condition
    I2C2CONbits.PEN = 1;
    while ( 1 ) {
        if ( I2C2STATbits.BCL ) return -13;
        if ( ! I2C2CONbits.PEN ) break;
    }

    return count;
}

int16_t i2c2Xfer(
	uint8_t address,
	uint8_t* wdata, int wsize,
	uint8_t* rdata, int rsize )
{
    int16_t result = i2c2XferInt( address, wdata, wsize, rdata, rsize );
    if ( result < 0 ) {
        // clear bus collision
        I2C2STATbits.BCL = 0;
        // clear start condition
        if ( I2C2STATbits.S )
            I2C2CONbits.PEN = 1;
    }
    return result;
}

void oledCommand( uint8_t ch )
{
    uint8_t bytes[2];
    bytes[0] = SSD1308_Command_Mode;
    bytes[1] = ch;
    i2c2Xfer( SSD1308_Address, bytes, 2, NULL, 0 );
}


void oledDisplayOffset( uint8_t offset )
{
    uint8_t bytes[3];
    bytes[0] = SSD1308_Command_Mode;
    bytes[1] = 0xD3;
    bytes[2] = offset;
    i2c2Xfer( SSD1308_Address, bytes, 3, NULL, 0 );
}


void oledData( uint8_t data )
{
    uint8_t bytes[2];
    bytes[0] = SSD1308_Data_Mode;
    bytes[1] = data;
    i2c2Xfer( SSD1308_Address, bytes, 2, NULL, 0 );
}


void oledGotoYX(unsigned char Row, unsigned char Column)
{
    oledCommand( 0xB0 + Row);
    oledCommand( 0x00 + (8*Column & 0x0F) );
    oledCommand( 0x10 + ((8*Column>>4)&0x0F) );
}


void oledPutChar( char ch )
{
    if ( ( ch < 32 ) || ( ch > 127 ) )
        ch = ' ';

    const uint8_t *base1 = &OledFont[ch - 32][0];

    uint8_t bytes[9];
    bytes[0] = SSD1308_Data_Mode;
    memmove( bytes + 1, base1, 8 );
    i2c2Xfer( SSD1308_Address, bytes, 9, NULL, 0 );
}


void oledPrint( char *s )
{
    while (*s) oledPutChar( *s++);
}


void oledClear()
{
    uint16_t row;
    uint16_t col;
    for ( row = 0; row < 8; row++ ) {
        for ( col = 0; col < 16; col++ ) {
            oledGotoYX( row, col );
            oledPutChar( ' ' );
        }
    }
}


void oledInit()
{
    oledCommand( SSD1308_Display_Off_Cmd );
    __delay_ms( 100 );
    oledCommand( SSD1308_Display_On_Cmd );
    __delay_ms( 100 );
    oledCommand( SSD1308_Normal_Display_Cmd );
    oledCommand( SSD1308_Dectivate_Scroll_Cmd );
}

void ssd_command(int cmd)
{
    uint8_t command_buffer[] = {0x00,0x00};
        
    command_buffer[0] = 0x00; //control byte
    command_buffer[1] = cmd;
    
    
    I2C2_MasterWrite( command_buffer ,2 ,0x3C, &status);
   
}


int main(void)
{
    // initialize the device
    SYSTEM_Initialize();
    //i2c2Enable(&status);
   

    
//    ANSA = 0;
//    ANSB = 0;
//    ANSF = 0;

//    __delay_ms( 2000 );
    
     uint32_t i;
         for(i = 0; i < 10000; i++){
             
         }

    //i2c2Reset();
    //i2c2Enable( kI2C_400KHZ );
//
//    oledInit();
//    oledClear();
//
//    oledGotoYX( 0, 0 );
//    oledPrint( "OLED SSD1308" );
    
        ssd_command(0xAF);
        ssd_command(0xA5);
        ssd_command(0xA7);
        ssd_command(SSD1308_Set_Brightness_Cmd);
        
        ssd_command( 0xB0 + 5);
        ssd_command( 0x00 + (8*5 & 0x0F) );
        ssd_command( 0x10 + ((8*5>>4)&0x0F) );

    uint16_t count = 0;
    while (1)
    {
        I2C2_Initialize();
        I2C2_
         ssd_command(0xAF);
         ssd_command(0x09);
         ssd_command(0x09);
         ssd_command(0x09);
//        
         
         for(i = 0; i < 100; i++){
             
         }
        
//        char s[20];
//        oledGotoYX( 2, 0 );
//        //oledPrint( s );
//        //oledPrint( "     " );
//        oledPutChar('1');
//        __delay_ms( 1 );
//        count++;
    }

    return 1;
}


/**
 End of File
*/

